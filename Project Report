XPDTweet-Project Report
Mobile Computing – 2012-2013
(Team XPD)
 


Course: MEIC A 01 EMDC Alameda Campus
Group:  13
Name: Xiao Chen                            Number: 77179              E-mail: Xiao.chen@ist.utl.pt
Name: Pradeeban Kathiravelu         Number: 77177             E-mail: Pradeeban.kathiravelu@ist.utl.pt
Name: Dipesh Dugar Mitthalal       Number: 77184              E-mail: Dipesh.Mitthalal@ist.utl.pt


 
1. Achievements
Team XPD has made best efforts to understand android development lifecycle and successfully able to implement the NearTweet project as per specifications provided. We have come up with Thick client, thin server approach in initial deployment which helped in achieving fully decentralized peer 2 peer NearTweet later stage. All use cases are implemented with full functionality. Keeping User privacy in mind, one can participate in tweet exchange without revealing identity. All communications will take place Via GroupOwner(GO) to mimic WIFI Direct Implementation. Optimizations for  less bandwidth usage is implemented by using serializable class, reduced Battery power consumption is achieved by allowing user to stop service when not participating and then synchronizing data while starting up the service again. User Interface is designed keeping all sizes and orientations of Devices into consideration to achieve maximum portability. Asynchronous tasks are used to perform network and media sharing related operations to keep UI smooth and Non blocking. Also GO can leave orderly or abruptly, our implementation handle it.
2. Specification
Here on, we will call our application as XPDTweet. User can be anonymous and use XPDTweet. Each application instance/user is identified by android ID and hence User’s NickName is just used for Display purpose. Assumption of one user/per phone is made in previous case. For polling, result will be displayed to all users who received poll. This will motivate users to participate in poll. XPDTweet uses relative time for displaying message creation time to user. For media sharing we faced challenge of handling it imposing less memory requirement for app’s whole content storage. Team came up with solution of just storing reference (Path or address of image) in application’s private storage and leave the file handling part to Android Storage.
Synchronizing data, when peer leaves group temporarily is a real challenge. Synchronizing whole data set in one time or one by one is issue to be addressed. Synchronizing with whom, is another challenge we faced. It’s a tradeoff that syncing whole data at once may be more CPU intensive and may fetch large data in one roundtrip but syncing one by one need more network messages and cumulatively more CPU usage while processing every network message. We decided to sync in one shot. When a user is not connected to group, he is allowed to create tweets which will be cached and delivered once he joins group. XPDTweet is scalable and it’s not restricted my number  of groups(assuming one bridge exists between any two groups).Also user has option to remove all tweets making application ready for the same user to use at other location. It is left to user choice whether to remove or Keep existing data using deleting all option in menu.
3. Design
We propose Fat Client and thin server approach for initial version of project (Centralized Version).The role of server here is to just broadcast the incoming messages to all other connected Peers. This approach will help us when we migrate from Centralized to Ad-Hoc Version.
In implementation of Ad-Hoc Version, All communication happens through Group owner. So basically GO just receives messages and broadcasts to others. This runs on independent thread in application. All clients will open connection in a separate thread, to GO when they receive Group Membership change. When a client leaves and joins back, group membership change triggers and everyone updates their connections.
XPDTweet application contains 5 Activities (UI screens) which interacts with user as shown in Figure 1. Also additional preference Activity is used. Network connections are put in a service class extending Android Service. Also a class which extends Android Application is used as a content provider as it will be available across all Application’s activities. We have created our custom List adapter to display tweets with sender, time and message in a single item. Each tweet, Retweet, Image share, Poll Request, Poll Reply, etc considered as a message with a type and unique ID. We construct each message as a serialized object of a class. When a service receives object from server (external world) it parses and store it in respective lists which will be called as content provider here on in Application Context. We have one list of storing all messages and other three Hash map which store Tweet-Replies and Poll-Replies and Poll-Options. When a service receives messages as a result of User input, it constructs object of a serialized class from message and sends it to external world. More details of each of the Activity and Design choice and its implementation is given in following sections.
 

4. Implementations Choices
Preference Screen: User can put in his preferred Nick name. User can navigate to preference screen by selecting a menu option. Also we are forcefully showing this screen if user has not picked his nickname for first time. This information is stored in phone even after application is killed and restarted and user can just use XPDTweet wherever needed with same Nickname. We have implemented preference on change listener as well which will update the application when a user changes his nickname after performing some tweets / replies.
TimeLine Activity: This is our main launching activity aimed to be like twitter’s wall, where user will be shown all types of tweets. Each tweet will have the Creator’s Name, Creation Time and the actual body of the tweet. Application also display the category along with it(whether it is Image, Poll, Tweet).To achieve this goal of displaying all possible details within limited space in a list, usage of Custom List adapter proved to be advantageous. We have implemented our custom arraylist adapter. When user clicks on any tweet, based on the type of tweet appropriate activity is launched.
Tweet Reply: When a user clicks on Tweet, a reply screen is opened where user is given option to replytoall, reply to owner, and share on FB or mark the creator as spam.
Share on FB: User has option to share original tweet, or tweet replies. Long click on any tweet reply will give user option to share on FB’s wall. User will be asked credentials of Facebook only for first time. Also user will be given warning about posting on wall publically (Permission request). Facebook user Credentials are stored encrypted.
Content Provider: Our content provider is Array list of objects mapped stored in application context. Application context is available as soon as application starts and will be available even when application is minimized and persistent state of data is maintained. We maintain one list for storing all posts and another two hash map for poll options and poll replies. A list is also maintained for keeping track of spammers. Every message exchanged across devices is serialized object. Each object has a type and a unique Id for identification purpose. Unique ID for each message is android_ID+timestamp. Android_ID is used to identify each application instance. This gives us an option for the user to be anonymous and use this application without revealing his Identification (name).We have not extended content provider classes as there is no requirement of sharing data with other applications. Our team has studied about android’s content provider class and came to a conclusion that if it’s a requirement of sharing data with other applications in Device, then extending content provider and using SQLite data base is useful which is not the requirement of XPDTweet application. We store replies of a tweet in a hash map of post_ID and list of replies. So when we get a message of type tweet reply we put it in hash map based on post_ID.
Service: We have created a service which runs till application is alive and sends and receives packets and supplies it to the content provider which is described above. Each message is received and handled based on its type. For centralized version, we have service connecting to server and keep listening for data. For P2P version we bind WIFI direct service with our application’s service and then take advantage of WIFI direct functionality. Once data is received as object, we parse it based on type and store it appropriately by sending it to our content provider and also notifying activities that dataset has changed. When application wants to send any message it contacts the service, to achieve the message transmission.
MultiMedia Sharing: Users of XPDTweet will be allowed to share images .When a user shows interest of sharing a picture along with a message he will be taken to new screen where he will be given option of selecting Images from Internal memory/Gallery or Take Picture from Camera. When a user selects picture from gallery, Image is repainted by decoding it based on screen size and when user decide to send it, we send the path of the image to the service and service takes up the image from the Gallery(Android MEDIA STORE) and compresses it and converts into Byte Array, serializes it and sends it as a object to the server. We chose to send path of image to backend service instead of image itself. This avoids out of memory error. If we manipulate a 1MB image in UI thread, app may be overloaded and may lead to abnormal crash of application. Hence we handle the sending of image from UI to backend service asynchronously so that UI doesn’t get hanged if image sending takes time.
When we receive image from other users, we get it as Byte array, we decode it and convert it into a jpg image and store it on internal SDcard and put the path of the image along with message in content provider. Timestamp is assigned for the name of the image. Our application is flexible enough to configure the image name like XPD+timestamp.  Storing the path instead of whole byte array gives better performance of the app. we wanted to make our content provider as light as possible to prevent slowdown of application and faster retrieval of data. So when user clicks on tweets with image he will be taken to other screen where image will be retrieved from SDcard based on the path present in message and image will be painted on screen based on screen size.
Sensor Data Sharing: We use the camera sensor to achieve this goal for XPDTweet application. User is given option to select picture from camera and share it with others. Image compression and decompression is handled as mentioned in previous section. We achieve code reusability here.
Spammer Detection: We are motivated from Facebook/Gmail concept of marking user as spam. That is if user mark anyone as spam we will not see his posts/messages in our wall/Inbox. We implemented same that is when user marks a tweet as spam, then that tweet’s owner will go in user’s spam list and then user will not be allowed to see that tweet. User will be given an alert that this tweet is marked as spam.
Reply to owner: Each user is identified by unique Android_ID. Android_ID is unique in each device provided by Android Security class and hence we reply to that Android_ID. Reply to owner functionality will also work even when owner is not present in group. This message will be delivered when owner joins the group as its piggy backed on SYNC reply.  ReplyToOwner option is disabled for the creator of the tweet. 
Polling: Each Near Tweet user is given option to create a poll with question and then user is taken to next screen where user can create options for the poll and click add button on the screen so that user can see the preview of the poll. Long click on the option will help user to delete the option. When user clicks Create Poll button user-Poll will be sent to Service and poll is actually getting created. After the creation, user can participate in poll by clicking on the poll-tweet in timeline activity. On clicking of the poll tweet, user will be taken to the activity where he can vote as well as see results. If user is already answered the poll and if he comes back he will not see the option to vote but he will see the results. Using the same activity screen for more than one purpose achieves the goal of modular programming and reuse. Also lesser the activity screen, application will be lighter and faster and will yield good performance. Every user who received the poll will see the results of the poll. “Why will I answer a poll if I don’t see result” is the question which drove us to above decision.
Synchronization: Client sends SYNC request to GO and GO Replies with its Dataset and then client merges the data received from GO. This happens only between client and GO. Validations are in place so that application does not give sync request when it does not have any data with it. Client only synchronizes tweets which it has seen in past. Poll results will also be synchronized so as to have a consistent state of data within a group. Equal method is overided efficiently in serialized class which helps in efficient comparison and merging of data received from other clients during SYNC process

Disconnected User: When a peer moves away, he will lose connectivity but still he will be able to create tweets. These tweets are delivered as soon as client gets connectivity. In this case user will be displayed message that his messages will be delivered later.
Intercommunication/Tweet Exchange: We exchange messages as a serialized class objects which reduces the sizes of messages exchanged considerably. Using JSON object for message exchange is also considered but it will increase the size of messages exchanged.
 5. Experimental Evaluation
Validations:  Clicking on send button when no input message is present. Each User can vote only once. Size of tweets/reply is restricted to 140 characters.
UI testing: we deploy application on emulator (nexus one) as well as Samsung i9000 galaxy device/Asus Nexus 7 to see the UI compatibility. All screens work fine except the camera Image capture. In real devices image is captured correctly but in emulator its orientation is changed by 90 Degree due to webcam integration of the Host laptop.
Application Size(.apk): 469KB
Test configuration:5 emulators  in one laptop with different configurations of screen size.
Average Messages Size: Tweet Creation and Reply -376Bytes (Approximation) but as serialized object.
Message-140 Char	Type 	User Name	Android-id	PostID	Timestamp	Total(approx)
280 Byte	4 Byte	20Byte	28 Byte	36Byte	8 Byte	376Bytes
Case 1 & 2 is tested with Move <GO> ( ) &  Deletegroup <GO> commands to evaluate orderly  and  randomly leaving   of peer or GO.
More than one bridge between two groups is not supported. Sending messages to owner of tweet when owner is not available and later respective messages are delivered, when respective client joins the group. Connecting using GO creates n connections rather than each client opens up connections up with everyone resulting in mesh network of n(n-1) connections. Following figures explains the different kinds of scalable topology XPDTweet supports.Traceview evaluation is given in Annexure
 
6. Conclusions
This project has provided a great learning opportunity for our team. Especially during the week when we were asked to study WIFI Direct and implement our own connect function. Going through android’s source code and its internal state machine mapping increased our zeal for learning. We have implemented XPDTweet keeping the performance and resource constraints of mobile in our mind and we think that that we have been successful in achieving it considerably. XPD is scalable with as many groups as needed. We tried to use as many androids UI components as possible to improve our understanding of context menus, main menus, alert dialog, shared preferences, custom adapters, SQLite (studied) etc. Overall it turned out to be a great learning experience.
7. Future Work
Undoing spam can be included along with deleting tweets one by one or multiple selections. Also video sharing can be incorporated. Also improved UI by displaying icon on each new tweet based on its type.NFC (Near Field Communication) based synchronization functionality can be included to synchronize between two NFC enabled phones. Presently we assume FIFO channel here .Ordering messages based on timestamp is not a good idea considering different time zones. Usage of vector or lamport or any other distributed clocks can be studied. 

8. References
During the initial days, our Team has undergone 20Hr online course on Android development conducted by G.Blake Meike who is author of 2 books related to Android Development. Also Android documentation and www.grepcode.com is helpful.
ANNEX-Evaluation of Trace View

 
We have run trace view analysis of our application when a group of two devices formed and exchange messages with each other. The above trace view shows that no thread/part of XPD tweet application uses 100% CPU and blocks the CPU. The Black portion represents the active state of any thread at given time and small red and green bars show the CPU consumption of individual objects at any instant. The pink color bar is highest one but it’s for drawing UI when application loads up. Also more than one thread with black bar shows that application is not doing everything on main thread. Due to lack of time more detailed evaluation is not presented.
